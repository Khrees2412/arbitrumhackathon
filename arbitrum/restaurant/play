// Allow cargo stylus export-abi to generate a main function.
#![cfg_attr(not(feature = "export-abi"), no_main)]
extern crate alloc;

// Set up a global memory allocator using MiniAlloc for efficient memory management in the smart contract.
#[global_allocator]
static ALLOC: mini_alloc::MiniAlloc = mini_alloc::MiniAlloc::INIT;



/// Import items from the SDK. The prelude contains common traits and macros.
use stylus_sdk::{alloy_primitives::U256, prelude::*, storage::{StorageMap, StorageUint}};
use alloy_primitives::{Address, Uint};

// Define some persistent storage using the Solidity ABI.
// Counter will be the entrypoint.
sol_storage! {
    pub struct RestaurantVoting {
        StorageMap<alloy_primitives::Address, StorageUint<256, 4>> votes;
        // Votes for each Restaurant (res id -> votes)
        StorageMap<alloy_primitives::Address, StorageUint<256, 4>> token_balances;
        // Stores token balances (user id -> token);
    }
}

impl RestaurantVoting {


    pub fn mint_tokens(&mut self, user: Address, amount: u32) {
        let balance: Uint<256, 4> = self.token_balances.get(user);

        self.token_balances.insert(user, balance + Uint::<256, 4>::from(amount));
    }

    // Function to submit a rating for a restaurant
    pub fn vote_restaurant(&mut self, user: Address, restaurant_id: Address, token_amount: Uint<256, 4>) -> Result<(), &str> {
        if token_amount % Uint::<256, 4>::from(100) != Uint::<256, 4>::from(0) {
            return Err("Token amount must be a multiple of 100.");
        }

        let required_tokens: Uint<256, 4>  = token_amount;

        if self.token_balances.get(user) < required_tokens {
            return Err("You do not have enough tokens to vote.");
        }

        let votes_to_add = token_amount / Uint::<256, 4>::from(100);

        let current_votes = self.votes.get(restaurant_id);
        self.votes.insert(restaurant_id, current_votes + votes_to_add);

        Ok(())

    }

    // Function to get the no. of votes of a restaurant
    pub fn get_votes(&self, restaurant_id: Address) -> Uint<256, 4> {
        self.votes.get(restaurant_id)
    }

    pub fn buy_tokens(&mut self,user_address: Address, amount: U256) {
        let mut token_balance_accessor: stylus_sdk::storage::StorageGuardMut<'_, stylus_sdk::storage::StorageUint<256, 4>> = self.token_balances.setter(user_address);
        let current_balance = token_balance_accessor.get();
        token_balance_accessor.set(current_balance + amount);
    }

}


// pub fn print_abi() {
//     // Import your contract struct here
//     // Remove the import statement if MyContract is not defined or not needed.

//     // Generate the ABI
//     let abi = Abi::new(RestaurantVoting::abi());

//     // Convert the ABI to a JSON string
//     let abi_json = serde_json::to_string_pretty(&abi).expect("Failed to serialize ABI to JSON");

//     // Print the ABI JSON
//     println!("{}", abi_json);
// }

// // If you need to include license and Solidity version, you can modify the function like this:
// pub fn print_abi_with_metadata(license: &str, solidity_version: &str) {
//     use crate::RestaurantVoting;

//     let abi = Abi::new(RestaurantVoting::abi());

//     let abi_with_metadata = serde_json::json!({
//         "license": license,
//         "solidityVersion": solidity_version,
//         "abi": abi
//     });

//     let abi_json = serde_json::to_string_pretty(&abi_with_metadata).expect("Failed to serialize ABI to JSON");

//     println!("{}", abi_json);
// }